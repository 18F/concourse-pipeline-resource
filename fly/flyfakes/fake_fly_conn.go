// This file was generated by counterfeiter
package flyfakes

import (
	"sync"

	"github.com/robdimsdale/concourse-pipeline-resource/fly"
)

type FakeFlyConn struct {
	LoginStub        func(target string, username string, password string) ([]byte, []byte, error)
	loginMutex       sync.RWMutex
	loginArgsForCall []struct {
		target   string
		username string
		password string
	}
	loginReturns struct {
		result1 []byte
		result2 []byte
		result3 error
	}
	GetPipelineStub        func(pipelineName string) ([]byte, []byte, error)
	getPipelineMutex       sync.RWMutex
	getPipelineArgsForCall []struct {
		pipelineName string
	}
	getPipelineReturns struct {
		result1 []byte
		result2 []byte
		result3 error
	}
	RunStub        func(...string) ([]byte, error)
	runMutex       sync.RWMutex
	runArgsForCall []struct {
		arg1 []string
	}
	runReturns struct {
		result1 []byte
		result2 error
	}
}

func (fake *FakeFlyConn) Login(target string, username string, password string) ([]byte, []byte, error) {
	fake.loginMutex.Lock()
	fake.loginArgsForCall = append(fake.loginArgsForCall, struct {
		target   string
		username string
		password string
	}{target, username, password})
	fake.loginMutex.Unlock()
	if fake.LoginStub != nil {
		return fake.LoginStub(target, username, password)
	} else {
		return fake.loginReturns.result1, fake.loginReturns.result2, fake.loginReturns.result3
	}
}

func (fake *FakeFlyConn) LoginCallCount() int {
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	return len(fake.loginArgsForCall)
}

func (fake *FakeFlyConn) LoginArgsForCall(i int) (string, string, string) {
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	return fake.loginArgsForCall[i].target, fake.loginArgsForCall[i].username, fake.loginArgsForCall[i].password
}

func (fake *FakeFlyConn) LoginReturns(result1 []byte, result2 []byte, result3 error) {
	fake.LoginStub = nil
	fake.loginReturns = struct {
		result1 []byte
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeFlyConn) GetPipeline(pipelineName string) ([]byte, []byte, error) {
	fake.getPipelineMutex.Lock()
	fake.getPipelineArgsForCall = append(fake.getPipelineArgsForCall, struct {
		pipelineName string
	}{pipelineName})
	fake.getPipelineMutex.Unlock()
	if fake.GetPipelineStub != nil {
		return fake.GetPipelineStub(pipelineName)
	} else {
		return fake.getPipelineReturns.result1, fake.getPipelineReturns.result2, fake.getPipelineReturns.result3
	}
}

func (fake *FakeFlyConn) GetPipelineCallCount() int {
	fake.getPipelineMutex.RLock()
	defer fake.getPipelineMutex.RUnlock()
	return len(fake.getPipelineArgsForCall)
}

func (fake *FakeFlyConn) GetPipelineArgsForCall(i int) string {
	fake.getPipelineMutex.RLock()
	defer fake.getPipelineMutex.RUnlock()
	return fake.getPipelineArgsForCall[i].pipelineName
}

func (fake *FakeFlyConn) GetPipelineReturns(result1 []byte, result2 []byte, result3 error) {
	fake.GetPipelineStub = nil
	fake.getPipelineReturns = struct {
		result1 []byte
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeFlyConn) Run(arg1 ...string) ([]byte, error) {
	fake.runMutex.Lock()
	fake.runArgsForCall = append(fake.runArgsForCall, struct {
		arg1 []string
	}{arg1})
	fake.runMutex.Unlock()
	if fake.RunStub != nil {
		return fake.RunStub(arg1...)
	} else {
		return fake.runReturns.result1, fake.runReturns.result2
	}
}

func (fake *FakeFlyConn) RunCallCount() int {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return len(fake.runArgsForCall)
}

func (fake *FakeFlyConn) RunArgsForCall(i int) []string {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return fake.runArgsForCall[i].arg1
}

func (fake *FakeFlyConn) RunReturns(result1 []byte, result2 error) {
	fake.RunStub = nil
	fake.runReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

var _ fly.FlyConn = new(FakeFlyConn)
